/*
	To save images for calibration
*/

#include "disparity/ueye_camera.h"
#include "disparity/ueye_exceptions.h"
#include "disparity/exceptions.h"
#include <opencv2/core/core.hpp>
#include "iostream"
#include <string>
#include <sstream>
#include "opencv2/calib3d/calib3d.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/contrib/contrib.hpp"
#include "opencv2/photo/photo.hpp"
#include <stdlib.h>

#include <stdio.h>

#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>

using namespace std;
using namespace cv;

// Camera class from library
CUeye_Camera ueye;
CUeye_Camera ueye_R;

//rosrun disparity dispairty --blocksize=5 -i intrinsics.yml -e extrinsics.yml

// GET IMAGE
//-----------------------------------------------------------------------------
cv::Mat* get_img(CUeye_Camera& cam)
{
  // Aacquire a single image from the camera
  bool image_ok = false;
  try
  {
    image_ok = cam.get_image();
  }
  catch (CUeyeCameraException & e)
  {
    cout << e.what () << endl;
    return false;
  }
  catch (CUeyeFeatureException & e)
  {
    cout << e.what () << endl;
  }

  int type;
  if(cam.params_.img_bpp==8) type=CV_8UC1;
  else if(cam.params_.img_bpp==24 || cam.params_.img_bpp==32) type=CV_8UC3;

  cv::Mat* image = NULL;

  if(image_ok) 
  {
    image = new cv::Mat(cam.params_.img_height, cam.params_.img_width, type);

    for (int jj = 0; jj < cam.img_data_size_; ++jj)
      image->at<unsigned char>(jj)=(unsigned char)cam.image_data_.at(jj);
  }

  return image;
}

//  INITIALIZE CAMERA
// -----------------------------------------------------------------------------
bool init_camera()
{
  // Initialize camera
  cout << "[Camera test]: Trying to open camera connection..." << endl;
  try
  {
    ueye.init_camera();
  }
  catch (CUeyeCameraException & e)
  {
    cout << e.what () << endl;
    return false;
  }
  catch (CUeyeFeatureException & e)
  {
    cout << e.what () << endl;
  }

  cout << "[Camera test]: Trying to open camera connection..." << endl;
  try
  {
    ueye_R.init_camera();
  }
  catch (CUeyeCameraException & e)
  {
    cout << e.what () << endl;
    return false;
  }
  catch (CUeyeFeatureException & e)
  {
    cout << e.what () << endl;
  }

  return true;
}

//  LIST AVAILABLE CAMERAS
// -----------------------------------------------------------------------------
bool list_cameras()
{
  // List cameras
  try
  {
    ueye.list_cameras();
  }
  catch (CUeyeCameraException & e)
  {
    cout << e.what () << endl;
    return false;
  }
  catch (CUeyeFeatureException & e)
  {
    cout << e.what () << endl;
  }
  return true;
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, "image_publisher");
  ros::NodeHandle nh;
  image_transport::ImageTransport it(nh);
  image_transport::Publisher pub1 = it.advertise("camera/image_left", 1);
  image_transport::Publisher pub2 = it.advertise("camera/image_right",1);
  //cv::Mat image = cv::imread(argv[1], CV_LOAD_IMAGE_COLOR);
  //cv::waitKey(30);
  sensor_msgs::ImagePtr msg1;
  sensor_msgs::ImagePtr msg2;

  // Define Initial parameters
  ueye.params_.cameraid=1;
  ueye.params_.img_width=752;
  ueye.params_.img_height=480;
  ueye.params_.img_left=-1;
  ueye.params_.img_top=-1;
  ueye.params_.fps=25;
  ueye.params_.param_mode=0;//1
  ueye.params_.file_str="";
  ueye.params_.pixel_clock=20;
  ueye.params_.exposure=8;
  ueye.params_.mirror_updown=false;
  ueye.params_.mirror_leftright=false;

  ueye_R.params_.cameraid=2;
  ueye_R.params_.img_width=752;
  ueye_R.params_.img_height=480;
  ueye_R.params_.img_left=-1;
  ueye_R.params_.img_top=-1;
  ueye_R.params_.fps=25;
  ueye_R.params_.param_mode=0;//0
  ueye_R.params_.file_str="";
  ueye_R.params_.pixel_clock=20;
  ueye_R.params_.exposure=8;
  ueye_R.params_.mirror_updown=false;
  ueye_R.params_.mirror_leftright=false;

  // Initialize camera
  if(!init_camera())
    return false;


/* 
    ueye.getExposure();
    ueye_R.set_exposure(ueye.input_exposure);
    ueye_R.getExposure();
    std::cout<<"ueye.input_exposure"<<ueye.input_exposure<<std::endl;
    std::cout<<"ueye_R.input_exposure"<<ueye_R.input_exposure<<std::endl;
*/
   
  // List cameras to choose which one is going to be tested
  //if(!list_cameras())
  //  return false;

  cv::Mat* frame_L;
  cv::Mat* frame_R;
  
 // frame_L = get_img(ueye);
 // frame_R = get_img(ueye_R);


   Mat img1;// = *frame_L;
    Mat img2;// = *frame_R;
int key = 'a';
int count = 0;
stringstream ss;
string str;


  ros::Rate loop_rate(5);
  while (nh.ok()) {


    // Get frame
    frame_L = get_img(ueye);
    frame_R = get_img(ueye_R);
    if(frame_L!=NULL && frame_R!=NULL) {  
   

      img1 = *frame_L;
      img2 = *frame_R;
    
      imshow("original1", img1);
      key = cv::waitKey(1);
      imshow("original2", img2);
      cv::waitKey(1);

      if(key==83||key==115)
      { 
         count++;
         string Result;          // string which will contain the result

         ostringstream convert;   // stream used for the conversion

         convert << count;      // insert the textual representation of 'Number' in the characters in the stream

         Result = convert.str(); // set 'Result' to the contents of the stream

         string filename1 = "/home/haibo/Desktop/ST/" + Result + "_1.png";
         string filename2 = "/home/haibo/Desktop/ST/" + Result + "_2.png";
         imwrite(filename1.c_str(), img1);
         imwrite(filename2.c_str(), img2);
         
      }


      //cv::destroyAllWindows();
      frame_L->release();
      frame_R->release();

      msg1 = cv_bridge::CvImage(std_msgs::Header(), "mono8", img1).toImageMsg();
      msg2 = cv_bridge::CvImage(std_msgs::Header(), "mono8", img2).toImageMsg();
      pub1.publish(msg1);
      pub2.publish(msg2);
      ros::spinOnce();
      loop_rate.sleep();
    }
 }
}
